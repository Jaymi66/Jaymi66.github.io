{"meta":{"title":"Zail's Blog","subtitle":"乱七八糟什么都渣的程序员.","description":"张二狗的博客, 张二狗, Zail's Blog, Zail","author":"Zail","url":"http://blog.fsocity.com"},"pages":[{"title":"关于我","date":"2017-03-27T10:48:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.fsocity.com/about/index.html","excerpt":"","text":"心中无码程序员一枚, 愿世界和平. My name is XiaoQiang Zhang(张晓强), you can call me Zail. I’m a WEB Developer. I love technology, such as React、 NodeJS、 MongoDB、 Docker…"},{"title":"所有分类","date":"2017-03-27T10:48:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"categories/index.html","permalink":"http://blog.fsocity.com/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-03-27T10:48:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.fsocity.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"理解Java 中的 transient 关键字","slug":"理解Java-中的-transient-关键字","date":"2018-05-25T03:03:59.000Z","updated":"2018-05-25T03:07:13.234Z","comments":true,"path":"2018/05/25/理解Java-中的-transient-关键字/","link":"","permalink":"http://blog.fsocity.com/2018/05/25/理解Java-中的-transient-关键字/","excerpt":"transient 瞬时的、瞬变的、短暂的meaning: working or staying somewhere for only a short timeJava 中的关键字 transient 表示,在持久化 Serialization 中的特殊的对象数据成员我们不想用 Serialization 的机制来保存它的时候,使用该关键字声明该字段是瞬时的.","text":"transient 瞬时的、瞬变的、短暂的meaning: working or staying somewhere for only a short timeJava 中的关键字 transient 表示,在持久化 Serialization 中的特殊的对象数据成员我们不想用 Serialization 的机制来保存它的时候,使用该关键字声明该字段是瞬时的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.fsocity.learn.java.transientt;import java.io.*;/** * @author zail * @since 2018-05-24 */public class TransientTest &#123; /** * 首先先说明 Serialization 的作用吧, * Serialization 是 Java 提供的一种机制叫做序列化, 有了这种机制我们就可以通过把某个对象序列化后 * 再次通过反序列化转换为我们创建的那个对象, 这样一来一回呢就实现了持久化的操作. 也就是说我们可以 * 先把某个对象序列化后保存成为一个文件, 再通过反序列化文件得到持久化的对象, 这样来实现持久化操作. * 而不是对象一直保持在程序执行的内存中创建销毁等. * &lt;p&gt; * 为什么会有 transient 这个关键字呢? * 就是因为当一个你想要用 Serialization 机制来持久化一个对象时, 该对象中有你不想持久化的成员对象. * 我们可以通过 transient 关键字来声明该成员不会被包含在序列化的范围内, 只保存在内存中. * * 输出: * Read before Serialization ... * username = zail * password = 123456 * Read after Serialization ... * username = zail * password = null * 说明反序列化时没有从文件中获取到 password 成员对象 * * * 小结: * 1. 一旦成员被 transient 修饰, 该成员则不再是对象持久化中的一部分, 该成员变量数据在序列化后无法获得. * 2. transient 关键字只能修饰成员变量, 不能修饰方法和类. * 注意: 本地成员变量是不能被 transient 关键字修饰的. 成员变量如果是用户自定义类变量, 则该类需要实现Serializable接口. * 3. 被 transient 关键字修饰的成员变量不再能被序列化, * 一个静态变量不管是否被 transient 修饰, 均不能被序列化. * * @param args */ public static void main(String[] args) &#123; User user = new User(); user.setUsername(\"zail\"); user.setPassword(\"123456\"); System.out.println(\"Read before Serialization ...\"); System.out.println(\"username = \" + user.getUsername()); System.out.println(\"password = \" + user.getPassword()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(\"/Users/zail/user.txt\")); os.writeObject(user); os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream( new FileInputStream(\"/Users/zail/user.txt\")); user = (User) is.readObject(); is.close(); System.out.println(\"Read after Serialization ...\"); System.out.println(\"username = \" + user.getUsername()); System.out.println(\"password = \" + user.getPassword()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = -639978949102211248L; private static String username; /** * 使用 transient 声明时, 不会序列化该成员 */ private transient String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.fsocity.learn.java.transientt;import java.io.*;/** * @author zail * @since 2018-05-25 */public class ExternalizableTest implements Externalizable &#123; private transient String content = \"是的, 我将会被序列化, 不管我是否被 transient 修饰.\"; public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; /** * 在Java中, 对象的序列化可以通过实现两种接口来实现. * 若实现的是 Serializable 接口, 则所有的序列化将会自动进行. * 若实现的是 Externalizable 接口, 则没有任何东西可以自动序列化. * 需要在 writeExternal 方法中进行手工指定所要序列化的变量. * 这与是否被transient修饰无关. 因此第二个例子输出的是变量 content 初始化的内容, 而不是null. * @param args * @throws IOException * @throws ClassNotFoundException */ public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream( new FileOutputStream(new File(\"test\"))); out.writeObject(et); ObjectInput in = new ObjectInputStream( new FileInputStream(new File(\"test\"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Java 设计模式-单例模式(Singleton)","slug":"Java-设计模式-单例模式-Singleton","date":"2018-01-22T03:23:50.000Z","updated":"2018-01-22T04:40:02.000Z","comments":true,"path":"2018/01/22/Java-设计模式-单例模式-Singleton/","link":"","permalink":"http://blog.fsocity.com/2018/01/22/Java-设计模式-单例模式-Singleton/","excerpt":"单例设计模式是Java中应用很广泛的设计模式之一, 保证了一个类始终有且只有一个对象, 具体特点有: 构造函数私有化(private) - 其它的类不能实例化创建该对象 引用时私有 - 外部不能修改该完成实例化的该类对象, 没有setInstance()方法 public static 方法是获取类对象的唯一方式","text":"单例设计模式是Java中应用很广泛的设计模式之一, 保证了一个类始终有且只有一个对象, 具体特点有: 构造函数私有化(private) - 其它的类不能实例化创建该对象 引用时私有 - 外部不能修改该完成实例化的该类对象, 没有setInstance()方法 public static 方法是获取类对象的唯一方式 单例模式的几种不同实现: 饿汉模式12345678910public class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton() &#123;&#125; public Singleton getInstance() &#123; return instance; &#125;&#125; 优点: 多线程安全 缺点: 加载类时就初始化完成,无法延时加载 懒汉模式12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优点: 可以延迟加载 缺点: 多线程不安全 双重检查1234567891011121314151617public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优点: 线程安全 延迟加载 缺点: 同步耗时 静态内部类123456789101112public class Singleton &#123; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125; private static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 优点: 线程安全 延迟加载 耗时短(与双重检查相比) 用缓存实现1234567891011121314151617181920public class Singleton &#123; private static final String KEY = \"InstanceKey\"; private static Map&lt;String, Singleton&gt; map = new HashMap&lt;&gt;(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; Singleton instance; if (map.get(KEY) == null) &#123; instance = new Singleton(); map.put(KEY, instance); &#125; else &#123; instance = map.get(KEY); &#125; return instance; &#125;&#125; 优点: 线程安全 缺点: 占用内存较大 枚举模式123456public enum Singleton &#123; INSTANCE; public void operate() &#123;&#125;&#125; 优点: 简洁 缺点: 占用内存大 参考Java设计模式—单例模式 - DevWiki","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.fsocity.com/tags/java/"},{"name":"design mode","slug":"design-mode","permalink":"http://blog.fsocity.com/tags/design-mode/"}],"keywords":[]},{"title":"Spring 4.3.12.RELEASE Core Container Imporvements(核心加强)","slug":"Spring4-3-12-RELEASE-Core-Container-Imporvements-核心加强","date":"2017-12-17T07:05:43.000Z","updated":"2017-12-17T16:08:13.000Z","comments":true,"path":"2017/12/17/Spring4-3-12-RELEASE-Core-Container-Imporvements-核心加强/","link":"","permalink":"http://blog.fsocity.com/2017/12/17/Spring4-3-12-RELEASE-Core-Container-Imporvements-核心加强/","excerpt":"Spring 文档链接","text":"Spring 文档链接 1. Annotations such as @Bean get detected and processed on Java 8 default methods as well, allowing for composing a configuration class from interfaces with default @Bean methods. @Bean 注解可以检查和执行 Java 8 默认方法(as well), 允许为一个接口装载一个实例化对象(使用类内部的方法). 示例: 123public interface UserService() &#123; void findUserById(Integer id);&#125; 1234567891011121314151617public Main() &#123; // 使用注解为 Service 装载实例 @Bean public UserService userServiceFindUserById() &#123; return new UserService() &#123; public void findUserById(Integer id) &#123; System.out.println(id); &#125; &#125;; &#125; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainTest.class); UserService userService = applicationContext.getBean(UserService.class); userService.findUserById(1); &#125;&#125; 2. Configuration classes may declare @Import with regular component classes now, allowing for a mix of imported configuration classes and component classes. 配置类可使用@Import导入单个或多个常规的组件类, 允许一个导入混合的配置类和组件类. 示例:123456@Componentpublic class ComponentClass &#123; public void print() &#123; System.out.println(\"ComponentClass\"); &#125;&#125; 123456789@Configuration@Import(value = &#123;ComponentClass.class, ...&#125;)public class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainTest.class); ComponentClass component = applicationContext.getBean(ComponentClass.class); component.print(); &#125;&#125; 3. Configuration classes may declare an @Order value, getting processed in a corresponding order (e.g. for overriding beans by name) even when detected through classpath scanning. 配置类可以声明一个@Order的值, 按照相对应的顺序进行处理(),支持对装载在诸如Lists和Arrays容器中的自动包装（auto-wired）组件的排序. 示例:12public interface RankService &#123;&#125; 12345678@Component@Order(2)public class RankServiceImpl01 implements RankService &#123; @Override public String toString() &#123; return \"RankServiceImpl01\"; &#125;&#125; 12345678@Component@Order(1)public class RankServiceImpl02 implements RankService &#123; @Override public String toString() &#123; return \"RankServiceImpl02\"; &#125;&#125; 12345678@Component@Order(3)public class RankServiceImpl03 implements RankService &#123; @Override public String toString() &#123; return \"RankServiceImpl03\"; &#125;&#125; 1234567891011@Componentpublic class Results &#123; @Autowired private List&lt;RankService&gt; rankService; @Override public String toString() &#123; return rankService.toString(); &#125;&#125; 12345678910@Configuration@ComponentScanpublic class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainTest.class); Results results = applicationContext.getBean(Results.class); // @Order 的值越小, 排序约靠前 System.out.println(results); // [RankServiceImpl02, RankServiceImpl01, RankServiceImpl03] &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.fsocity.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://blog.fsocity.com/tags/spring/"}],"keywords":[]},{"title":"理解说明Servlet生命周期.","slug":"理解说明Servlet生命周期","date":"2017-11-15T03:08:27.000Z","updated":"2017-11-15T03:17:27.000Z","comments":true,"path":"2017/11/15/理解说明Servlet生命周期/","link":"","permalink":"http://blog.fsocity.com/2017/11/15/理解说明Servlet生命周期/","excerpt":"理解 Servlet 的生命周期","text":"理解 Servlet 的生命周期 Servlet 有三个阶段: 初始化:当容器启动或者第一次执行, Servlet#init(ServletConfig) 方法被执行, 初始化当前 Servlet. 处理请求:当 HTTP 请求到达容器时, Servlet#service(ServletRequest, ServletResponse) 方法被执行, 来处理请求. 其中 ServletRequest 是请求对象(输入), ServletResponse 是响应对象(输出) 销毁:当容器关闭时, 容器会调用Servlet#destory方法被执行, 销毁当前 Servlet.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.fsocity.com/tags/java/"},{"name":"servlet","slug":"servlet","permalink":"http://blog.fsocity.com/tags/servlet/"}],"keywords":[]},{"title":"Java访问控制和应用场景","slug":"Java访问控制和应用场景","date":"2017-11-10T02:59:12.000Z","updated":"2017-11-15T03:08:51.000Z","comments":true,"path":"2017/11/10/Java访问控制和应用场景/","link":"","permalink":"http://blog.fsocity.com/2017/11/10/Java访问控制和应用场景/","excerpt":"Java 中的访问控制关键字是负责类内部成员变量和方法安全性的, 简单的说关键字是为设置外部是否能直接访问到该类内部的成员变量和方法而生的.","text":"Java 中的访问控制关键字是负责类内部成员变量和方法安全性的, 简单的说关键字是为设置外部是否能直接访问到该类内部的成员变量和方法而生的. Java 中有三个访问控制符, 分别是: public、protected、private 有四种访问权限, 分别是: default、public、protected、private 在类中声明属性和方法, 包括声明内部类时, 都可以关键字声明对应的访问权限. default: 默认包访问权限, 声明属性和方法时, 如果没有使用任何的权限声明则使用default权限. 默认权限是本包的其他类都可以访问, 但无法被其它包的类访问. public: 公共访问权限, 使用public进行权限控制, public 权限可以被所有的类访问. protected: 继承访问权限, 使用protected进行权限控制, protected权限可以被本包中的其他类和其它包中的子类访问到. private: 私有访问权限, 使用关键字private进行权限控制, 使用private声明的成员变量和方法只能在本类中被访问, 其它所有类都无法访问. 范围 private default protected public 同一个类中 √ √ √ √ 同一个包中(子类和非子类) × √ √ √ 不同包中的子类 × × √ √ 不同包中的非子类 × × × √ 应用场景 default: 如果不写访问权限关键字则是default, 比如在定义接口是可以不写内部方法的权限控制, 该接口可以被本包的类实现. public: main方法必须用public, 因为该方法要被JVM外部访问到. public的应用场景很广泛, 如POJO类中的getter``setter方法都需要设置public. protected: protected比较特殊, 也少有对应的应用场景, 如果你想该成员变量和方法只能被外部的子类访问到, 则使用该关键字. private: 私有访问权限的意思是外部完全访问不到, 如POJO的成员变量不能被外部直接访问到, 所以会设置为private.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://blog.fsocity.com/tags/java/"}],"keywords":[]},{"title":"详解jQuery.print.js打印网页.","slug":"详解jQuery-print-js打印网页","date":"2017-03-28T04:05:53.000Z","updated":"2017-11-15T03:09:38.000Z","comments":true,"path":"2017/03/28/详解jQuery-print-js打印网页/","link":"","permalink":"http://blog.fsocity.com/2017/03/28/详解jQuery-print-js打印网页/","excerpt":"jQuery.print.js 是基于jQuery的网页打印插件, 可以打印全网页, 也可以打印页面某一部分. GitHub 使用很简单","text":"jQuery.print.js 是基于jQuery的网页打印插件, 可以打印全网页, 也可以打印页面某一部分. GitHub 使用很简单 html代码:1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh_cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"print\"&gt; &lt;p&gt;123&lt;/p&gt; &lt;p&gt;456&lt;/p&gt; &lt;p&gt;789&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://libs.baidu.com/jquery/1.11.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/jQuery.print.js\"&gt;&lt;/script&gt; &lt;script&gt; $('#print').print() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参数列表: 1. globalStyles 说明: 是否包含父元素的样式 参数类型: Boolean 默认: true 2. mediaPrint 说明: 是否应包括带有media=’print’的链接标签 参数类型: Boolean 默认: false 3. stylesheet 说明: 添加一个外部的css样式文件 参数类型: URL-string 默认: null 4. noPrintSelector 说明: 跳过打印的标签, 元素带有class=”no-print”时跳过打印. 参数类型: Any valid jQuery-selector 默认: “.no-print” 5. iframe 说明: 是否从iframe中打印, 可以使用自己定义的iframe元素, 注意: 设置为false时, chrome会拦截. 参数类型: Any valid jQuery-selector or Boolean 默认: true, 如果iframe参数无效, 则创建一个隐藏的iframe 6. append/prepend 说明: 添加选中的html元素或自定义标签, prepend(在前面添加), append(在后面添加) 参数类型: Any valid jQuery-selector or HTML-text 默认: null 7. title 说明: 修改打印标题, 默认html文档标题 参数类型: string 默认: null","categories":[],"tags":[{"name":"jquery.js","slug":"jquery-js","permalink":"http://blog.fsocity.com/tags/jquery-js/"},{"name":"jquery.print.js","slug":"jquery-print-js","permalink":"http://blog.fsocity.com/tags/jquery-print-js/"}],"keywords":[]},{"title":"Ubuntu14.04下安装MongoDB并创建用户","slug":"Ubuntu14-04下安装MongoDB并创建用户","date":"2017-01-06T06:06:38.000Z","updated":"2017-11-15T03:10:01.000Z","comments":true,"path":"2017/01/06/Ubuntu14-04下安装MongoDB并创建用户/","link":"","permalink":"http://blog.fsocity.com/2017/01/06/Ubuntu14-04下安装MongoDB并创建用户/","excerpt":"在 Ubuntu14 下安装 MongoDB 并创建用户开启鉴权 由于阿里云通知我，我的MongoDB服务器有安全漏洞，是因为之前没有设置权限，所以特写次文章","text":"在 Ubuntu14 下安装 MongoDB 并创建用户开启鉴权 由于阿里云通知我，我的MongoDB服务器有安全漏洞，是因为之前没有设置权限，所以特写次文章 安装Mongodb1. 下载最新版 MongoDB1$ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1404-3.4.1.tgz 2. 解压下载好的 taz 包, 并重命名12$ tar -zxvf mongodb-linux-x86_64-ubuntu1404-3.4.1.tgz$ mv mongodb-linux-x86_64-ubuntu1404-3.4.1.tgz mongodb 3. 编写配置文件 mongodb.conf123456789101112# 数据库存放路径（这里写的是相对路径）dbpath=data/db# 端口号port=27017# 先把auth关闭，添加用户后再开启auth=false# 日志文件存放路径logpath=mongodb.log# 日志是否追加logappend=true# 后台进程启动fork=true 4. 创建数据库存放目录，并修改权限12$ mkdir -p data/db$ chmod -R 777 data/db/ 5. 启动服务1$ ./bin/mongod -f mongodb.conf 6. 连接到 mongodb12345./bin/mongoMongoDB shell version v3.4.1connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.1&gt; 请自行设置 $PATH这时候我们看一下log日志后有3个警告信息分别为，暂时我还不会解决…1). WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine2). WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’. We suggest setting it to ‘never’3). WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’ 创建用户并使用 注意：MongoDB 2.6 版本之前使用 db.addUser() 创建用户, 2.6 版本之后使用 db.createUser() 创建用户 123456789101112131415161718192021222324addUser() 参数只有两个 1. 用户名 2. 密码createUser() 有多个参数, 分别为 &#123; user: &lt;name&gt;, pwd: &lt;password&gt;, customData: &lt;用户说明&gt;, roles: [ &#123; role: &lt;角色类型&gt;, db: &lt;创建在哪个数据库&gt; &#125; ] &#125;数据库角色类型分别有: ( read: 只读 readWrite: 读写 dbAdmin: 数据库管理权限 dbOwner: 前三者的集合体，有前三者所有的权限 userAdmin: 用户管理 )了解了这么多，接下来就要创建用户了 1. 创建用户 创建一个admin账户用来管理所有的用户，再创建一个个人账号用来管理所有的数据库 12345# 创建一个admin，给予userAdminAnyDatabase的权限，可以管理所有的用户：&gt; db.createUser(&#123;user: &apos;useradmin&apos;, pwd: &apos;useradmin&apos;, roles: [&#123;role: &apos;userAdminAnyDatabase&apos;, db: &apos;admin&apos;&#125;]&#125;)# 创建一个个人用户，给予dbAdminAnyDatabase的权限，可以管理所有数据库：&gt; db.createUser(&#123;user: &apos;zail&apos;, pwd: &apos;zail&apos;, roles: [&#123;role: &apos;dbAdminAnyDatabase&apos;, db: &apos;admin&apos;&#125;]&#125;)# 之后就可以通过 admin 账户来管理用户， 通过自己的账号来管理所有的数据库 2. 开启鉴权认证123456789101112# 关闭 MongoDB&gt; use admin&gt; db.shutdownServer()# 修改配置文件 mongodb.conf 中的 auth=true# 保存# 重启 MongoDB$ ./bin/mongod -f mongodb.conf# 之后就可以使用账号链接 MongoDB 了$ ./bin/mongo admin -u admin -p admin$ ./bin/mongo admin -u zail -p zail","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.fsocity.com/tags/mongodb/"}],"keywords":[]},{"title":"如何写pm2 start文件","slug":"如何写pm2-start文件","date":"2016-12-02T03:22:54.000Z","updated":"2017-11-15T03:09:13.000Z","comments":true,"path":"2016/12/02/如何写pm2-start文件/","link":"","permalink":"http://blog.fsocity.com/2016/12/02/如何写pm2-start文件/","excerpt":"🍺 pm2 是啥我就不过多介绍了, 总之是神器. pm2 写一个配置文件就可以运行你的代码. 写出配置文件后就不用每次写命令时带很多参数了, 减轻了命令行的代码量.同时查看log信息也不需要用命令行查看, 直接把log文件打印到项目中随时查看log, 方便快捷.","text":"🍺 pm2 是啥我就不过多介绍了, 总之是神器. pm2 写一个配置文件就可以运行你的代码. 写出配置文件后就不用每次写命令时带很多参数了, 减轻了命令行的代码量.同时查看log信息也不需要用命令行查看, 直接把log文件打印到项目中随时查看log, 方便快捷. 项目根目录新建一个 pm2.config.json 文件 👇 123456789101112131415161718&#123; // 项目名称 \"name\": \"app name\", // 启动文件 \"script\": \"./app.js\", // 是否监听文件变化 \"watch\": true, // 如果你是koa框架需要加入 --harmony 或者别的参数都可以加到这里 \"node_args\": \"--harmony\", // log 相关 // 输出 log 时, 前缀时间格式化 \"log_date_format\": \"YYYY-MM-DD HH:mm Z -&gt; \", // out log 文件地址 \"out_file\": \"./logs/pm2-out.log\", // error log 文件地址 \"error_file\": \"./logs/pm2-error.log\"&#125; 更多参数请查看 官方文档","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://blog.fsocity.com/tags/node-js/"},{"name":"pm2","slug":"pm2","permalink":"http://blog.fsocity.com/tags/pm2/"}],"keywords":[]},{"title":"初体验facebook开源包管理工具yarn","slug":"初体验facebook开源包管理工具yarn","date":"2016-10-18T06:27:07.000Z","updated":"2017-11-15T03:09:05.000Z","comments":true,"path":"2016/10/18/初体验facebook开源包管理工具yarn/","link":"","permalink":"http://blog.fsocity.com/2016/10/18/初体验facebook开源包管理工具yarn/","excerpt":"害怕 facebook 网站小伙伴们被墙, 搞了传到 csdn 的图片一张. 我勒个去，现在的 node 相关的开源社区太活跃了，github 上 facebook 活跃度已经是第二了，第一是微软🙄. yarn 又是什么？ →_→ 包管理工具 包管理工具不是有: npm、bower …… 了吗!？ →_→ 好用吗？下载速度快吗？安全吗？可靠吗？有良好的依赖吗？ 不知道 … 凑合用吧.","text":"害怕 facebook 网站小伙伴们被墙, 搞了传到 csdn 的图片一张. 我勒个去，现在的 node 相关的开源社区太活跃了，github 上 facebook 活跃度已经是第二了，第一是微软🙄. yarn 又是什么？ →_→ 包管理工具 包管理工具不是有: npm、bower …… 了吗!？ →_→ 好用吗？下载速度快吗？安全吗？可靠吗？有良好的依赖吗？ 不知道 … 凑合用吧. 哈哈哈哈开始说之前, 我也说不出来 npm 是不是好用, 但是慢不是一个人说的, 我觉得也慢. yarn 还简化了 npm 的使用. 就冲这两点, 也应该看一下. 好下面直接开始! 安装1$ npm install -g yarn 初始化1234$ yarn init# 查看是否正确安装好$ yarn --version 我尼玛和 npm 有什么区别!？ 别着急嘛 管理依赖添加依赖12# 这里不需要 --save 参数直接可以写到 package.json 文件里, 后面可跟@version版本号、也可以跟@tag 指代git上的推送的tag$ yarn add [package] 更新依赖12# 更新某个包, 同时也有 @version 、 @tag. 不加包名即更新所有依赖$ yarn upgrade [package] 移除依赖12# 移除某个包 $ yarn remove [package] 如果有 package.json 或者是 bower.json12# 直接 yarn 或者 yarn install 即可安装所有依赖$ yarn 下一个包玩玩1234567891011$ yarn add g2yarn add v0.15.1info No lockfile found.[1/4] 🔍 Resolving packages...[2/4] 🚚 Fetching packages...[3/4] 🔗 Linking dependencies...[4/4] 📃 Building fresh packages...success Saved lockfile.success Saved 1 new dependency└─ g2@2.0.4✨ Done in 2.10s. 运行下来没有那么多警告, 还有很友好的时间等其他的提示, 还会直接建立 package.json 文件. 12345&#123; &quot;dependencies&quot;: &#123; &quot;g2&quot;: &quot;^2.0.4&quot; &#125;&#125; 是不是用着很舒服呢？ 至于那个什么锁的东西我还不会…😁哈哈哈哈","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://blog.fsocity.com/tags/node-js/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.fsocity.com/tags/yarn/"}],"keywords":[]},{"title":"理解MongoDB的mapReduce使用及流程","slug":"理解MongoDB的mapReduce使用及流程","date":"2016-10-18T02:39:11.000Z","updated":"2017-11-15T03:09:29.000Z","comments":true,"path":"2016/10/18/理解MongoDB的mapReduce使用及流程/","link":"","permalink":"http://blog.fsocity.com/2016/10/18/理解MongoDB的mapReduce使用及流程/","excerpt":"mapReduce 是一个多层分组查询的方法(这是个人理解的) 可以分为四层 第一层: query 层 // 意思是把数据进行筛选 第二层: map 方法层 // 分组数据处理, 把数据作为 key values 的形式传进 reduce 层 第三层: reduce 方法层 // 统计函数, 把传进来的 key values 转换成想要的 key value 形式 第四层: finalize 方法层 // 最后的确认函数 Map-Reduce 例子","text":"mapReduce 是一个多层分组查询的方法(这是个人理解的) 可以分为四层 第一层: query 层 // 意思是把数据进行筛选 第二层: map 方法层 // 分组数据处理, 把数据作为 key values 的形式传进 reduce 层 第三层: reduce 方法层 // 统计函数, 把传进来的 key values 转换成想要的 key value 形式 第四层: finalize 方法层 // 最后的确认函数 Map-Reduce 例子 12345678910111213141516171819202122db.collection.mapReduce( // 第二步: 执行 map 函数, 必须有 emit 方法 function () &#123; // emit 方法遍历 collection 中所有的记录 emit(this.user_name, 1); // -&gt; &#123;key: mark, values: [1,1,1,1]&#125; &#123;key: runoob, values: 1&#125; &#125;, // 第三步: 执行 reduce 函数, 遍历 map 函数得出的对象数组 function (key, values) &#123; // -&gt; [&#123;key: mark, valuse: [1,1,1,1]&#125;, &#123;key: runoob, values: 1&#125;] // return 的数据 为需要存储的数据 -&gt; &#123;value: &#123;value1: 4, value2: 4&#125;&#125; return &#123;value1: values.length, value2: Array.sum(values)&#125;; &#125;, // 第一步: collection 和 条件 相关 &#123; out: 'post_total', // &#123; merge: \"collection\" &#125; 如果有 collection 会重写 数据, 可 merge query: &#123;status: 'active'&#125;, // 最后确定的方法 finalize: function (key, value) &#123; &#125; &#125;)","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.fsocity.com/tags/mongodb/"}],"keywords":[]},{"title":"分享知乎的一个话题。","slug":"分享知乎的一个话题。","date":"2016-08-19T04:21:30.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/08/19/分享知乎的一个话题。/","link":"","permalink":"http://blog.fsocity.com/2016/08/19/分享知乎的一个话题。/","excerpt":"有哪些短小却令人惊叹的 JavaScript 代码？","text":"有哪些短小却令人惊叹的 JavaScript 代码？","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.fsocity.com/tags/javascript/"}],"keywords":[]},{"title":"原生javascript如何解决ajax跨域的问题？","slug":"原生javascript如何解决ajax跨域的问题？","date":"2016-08-05T02:53:03.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/08/05/原生javascript如何解决ajax跨域的问题？/","link":"","permalink":"http://blog.fsocity.com/2016/08/05/原生javascript如何解决ajax跨域的问题？/","excerpt":"大家知道 jQuery 解决 ajax 跨域的问题很方便，直接用 jsonp 的方式提交就 ok ，网上有很多解决的办法，但是有些时候我们不得不用原生 js 来写很多东西，所以我今天把原生 js 解决 ajax 跨域的问题用一个很简单的方法来实现。","text":"大家知道 jQuery 解决 ajax 跨域的问题很方便，直接用 jsonp 的方式提交就 ok ，网上有很多解决的办法，但是有些时候我们不得不用原生 js 来写很多东西，所以我今天把原生 js 解决 ajax 跨域的问题用一个很简单的方法来实现。 首先来理解它的原理: 实际上实现跨域不是用的传统的 XMLHttpRequest 对象，而是用了 script 标签可以访问其它的网址的 js 来实现的。 直接上代码 12345678910111213141516171819202122232425262728293031function jsonp(options) &#123; options = options || &#123;&#125;; if (!options.url || !options.callback) &#123; throw new Error(\"参数不合法\"); &#125; // 创建 script 标签并加入到页面中 var callbackName = ('jsonpcallback_' + Math.random()).replace(\".\", \"\"); // 随机一个比较长的回调函数名称 var oHead = document.getElementsByTagName('head')[0]; options.data[options.callback] = callbackName; // 把回调函数名字加入到 options.data 中 var params = formatParams(options.data); // 格式化数据 var oS = document.createElement('script'); oHead.appendChild(oS); // 创建jsonp回调函数 window[callbackName] = function (json) &#123; oHead.removeChild(oS); clearTimeout(oS.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); &#125;; // 发送请求 oS.src = options.url + '?' + params; // 超时处理 if (options.time) &#123; oS.timer = setTimeout(function () &#123; window[callbackName] = null; oHead.removeChild(oS); options.error &amp;&amp; options.error(&#123; message: \"超时\" &#125;); &#125;, options.time); &#125;&#125; formatParams 方法 12345678function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + \"=\" + encodeURIComponent(data[name])); &#125; arr.push((\"v=\" + Math.random()).replace(\".\", \"\")); return arr.join(\"&amp;\");&#125; 执行 1234567891011121314jsonp(&#123; url: \"http://www.XXX.com/\", callback: \"callback\", // callback 的名称要记住 time: 5000, data: &#123; a: 1 &#125;, success: function (data) &#123; console.log(\"提交成功!\"); &#125;, error: function (err) &#123; console.log(err); &#125;&#125;); 可以在浏览器中看到，我们向服务器端发送的数据是 GET 请求，数据有两个，一个是参数 a: 1 另一个是 callback: jsonpcallback_***. 为什么会有两个参数？ 其实我们没有发送数据请求， 我们只是创建了一个 script 标签， 连接到一个 js 文件，来执行这个 js 文件罢了。 所以就要后台返回的值需要是一段执行的 js 方法， 方法名称已经用 callback 参数发送过去了，只需要把参数执行就可以了. 后台返回的示例（以 callback: jsonpcallback_*** 为例）， json 为后台返回的数据，执行这个方法就可以执行 success 中写的方法了 1jsonpcallback_***(json)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.fsocity.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://blog.fsocity.com/tags/ajax/"}],"keywords":[]},{"title":"iPhone 网页中手机号码显示样式问题。","slug":"iPhone-网页中手机号码显示样式问题。","date":"2016-06-26T14:05:26.000Z","updated":"2017-11-15T03:09:51.000Z","comments":true,"path":"2016/06/26/iPhone-网页中手机号码显示样式问题。/","link":"","permalink":"http://blog.fsocity.com/2016/06/26/iPhone-网页中手机号码显示样式问题。/","excerpt":"我们在做 iPhone 上的网页的时候会遇到手机号码莫名显示为蓝色的问题,这是 iPhone 上的 safari 内核的浏览器会自动为手机号码添加 link 以及 link 的样式，如果这是我们不需要的，该如何禁用掉呢？","text":"我们在做 iPhone 上的网页的时候会遇到手机号码莫名显示为蓝色的问题,这是 iPhone 上的 safari 内核的浏览器会自动为手机号码添加 link 以及 link 的样式，如果这是我们不需要的，该如何禁用掉呢？ 我们可以添加 meta 标签来禁用掉手机号码自动添加link的功能 1&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://blog.fsocity.com/tags/web/"},{"name":"iphone","slug":"iphone","permalink":"http://blog.fsocity.com/tags/iphone/"}],"keywords":[]},{"title":"如何解决Zepto.js 和 jQuery.js 事件多次执行多次bind?","slug":"如何解决Zepto-js-和-jQuery-js-事件多次执行多次bind","date":"2016-06-26T09:51:48.000Z","updated":"2017-11-15T03:09:24.000Z","comments":true,"path":"2016/06/26/如何解决Zepto-js-和-jQuery-js-事件多次执行多次bind/","link":"","permalink":"http://blog.fsocity.com/2016/06/26/如何解决Zepto-js-和-jQuery-js-事件多次执行多次bind/","excerpt":"Zepto.js 和 jQuery.js 绑定click事件的时候,如果多次执行监听事件,会出现累积bind同一个事件的问题。 这时候执行该事件会根据绑定的次数来多次执行该事件，如何解决这个问题？","text":"Zepto.js 和 jQuery.js 绑定click事件的时候,如果多次执行监听事件,会出现累积bind同一个事件的问题。 这时候执行该事件会根据绑定的次数来多次执行该事件，如何解决这个问题？ Zepto.js 和 jQuery.js 绑定click事件的时候,如果多次执行监听事件,会出现累积bind同一个事件的问题。 这时候执行该事件会根据绑定的次数来多次执行该事件，如何解决这个问题？ 如何让事件多次执行监听而只bind一次。 1$(‘.class’).unbind(‘click’).on(‘click’, function()&#123; … &#125;); 可以通过 先解绑 click 事件，然后再 bind click 事件来解决。","categories":[],"tags":[{"name":"jquery.js","slug":"jquery-js","permalink":"http://blog.fsocity.com/tags/jquery-js/"},{"name":"zepto.js","slug":"zepto-js","permalink":"http://blog.fsocity.com/tags/zepto-js/"}],"keywords":[]},{"title":"如何编写Markdown文件","slug":"如何编写Markdown文件","date":"2016-06-26T09:35:01.000Z","updated":"2017-11-15T03:09:17.000Z","comments":true,"path":"2016/06/26/如何编写Markdown文件/","link":"","permalink":"http://blog.fsocity.com/2016/06/26/如何编写Markdown文件/","excerpt":"使用 Markdown 的优点 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。","text":"使用 Markdown 的优点 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 详细信息查看 转载的GitBook 标题语法123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 无序列表123- 1- 2- 3 1 2 3 有序列表123* 1* 2* 3 1 2 3 引用1&gt; 这里是引用的内容 这里是引用的内容 链接1段落中需要插入链接： [baidu](www.baidu.com) 点击可以访问. 段落中需要插入链接： baidu 点击可以访问. 插入图片1![pic](https://www.getcloudapp.com/assets/images/app_image_win@2x.jpg) 粗体1**粗体** 这里是粗体 斜体1*斜体* 这里是斜体 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码1`code` code 分割线1***","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.fsocity.com/tags/markdown/"}],"keywords":[]}]}