{"meta":{"title":"Zail's Blog","subtitle":"一个想做Node的前端","description":"张晓强的博客, 前端开发工程师 加QQ群 165905011","author":"Zail","url":"http://mysaul.com"},"pages":[{"title":"关于我","date":"2017-03-27T10:48:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"about/index.html","permalink":"http://mysaul.com/about/index.html","excerpt":"","text":"心中无码程序员一枚, 愿世界和平. My name is XiaoQiang Zhang(张晓强), you can call me Zail. I’m a WEB Developer. I love technology, such as React、 NodeJS、 MongoDB、 Docker…"},{"title":"所有分类","date":"2017-03-27T10:48:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"categories/index.html","permalink":"http://mysaul.com/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-03-27T10:48:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"tags/index.html","permalink":"http://mysaul.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java访问控制和应用场景","slug":"Java访问控制和应用场景","date":"2017-11-10T02:59:12.000Z","updated":"2017-11-11T02:29:09.000Z","comments":true,"path":"2017/11/10/Java访问控制和应用场景/","link":"","permalink":"http://mysaul.com/2017/11/10/Java访问控制和应用场景/","excerpt":"Java 中的访问控制关键字是负责类内部成员变量和方法安全性的, 简单的说关键字是为设置外部是否能直接访问到该类内部的成员变量和方法而生的.","text":"Java 中的访问控制关键字是负责类内部成员变量和方法安全性的, 简单的说关键字是为设置外部是否能直接访问到该类内部的成员变量和方法而生的. Java 中有三个访问控制符, 分别是: public、protected、private 有四种访问权限, 分别是: default、public、protected、private 在类中声明属性和方法, 包括声明内部类时, 都可以关键字声明对应的访问权限. default: 默认包访问权限, 声明属性和方法时, 如果没有使用任何的权限声明则使用default权限. 默认权限是本包的其他类都可以访问, 但无法被其它包的类访问. public: 公共访问权限, 使用public进行权限控制, public 权限可以被所有的类访问. protected: 继承访问权限, 使用protected进行权限控制, protected权限可以被本包中的其他类和其它包中的子类访问到. private: 私有访问权限, 使用关键字private进行权限控制, 使用private声明的成员变量和方法只能在本类中被访问, 其它所有类都无法访问. 范围 private default protected public 同一个类中 √ √ √ √ 同一个包中(子类和非子类) × √ √ √ 不同包中的子类 × × √ √ 不同包中的非子类 × × × √ 应用场景 default: 如果不写访问权限关键字则是default, 比如在定义接口是可以不写内部方法的权限控制, 该接口可以被本包的类实现. public: main方法必须用public, 因为该方法要被JVM外部访问到. public的应用场景很广泛, 如POJO类中的getter``setter方法都需要设置public. protected: protected比较特殊, 也少有对应的应用场景, 如果你想该成员变量和方法只能被外部的子类访问到, 则使用该关键字. private: 私有访问权限的意思是外部完全访问不到, 如POJO的成员变量不能被外部直接访问到, 所以会设置为private.","categories":[],"tags":[],"keywords":[]},{"title":"详解jQuery.print.js打印网页.","slug":"详解jQuery-print-js打印网页","date":"2017-03-28T04:05:53.000Z","updated":"2017-03-28T06:46:31.000Z","comments":true,"path":"2017/03/28/详解jQuery-print-js打印网页/","link":"","permalink":"http://mysaul.com/2017/03/28/详解jQuery-print-js打印网页/","excerpt":"jQuery.print.js 是基于jQuery的网页打印插件, 可以打印全网页, 也可以打印页面某一部分. GitHub 使用很简单","text":"jQuery.print.js 是基于jQuery的网页打印插件, 可以打印全网页, 也可以打印页面某一部分. GitHub 使用很简单 html代码:1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh_cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"print\"&gt; &lt;p&gt;123&lt;/p&gt; &lt;p&gt;456&lt;/p&gt; &lt;p&gt;789&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://libs.baidu.com/jquery/1.11.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/jQuery.print.js\"&gt;&lt;/script&gt; &lt;script&gt; $('#print').print() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参数列表: 1. globalStyles 说明: 是否包含父元素的样式 参数类型: Boolean 默认: true 2. mediaPrint 说明: 是否应包括带有media=’print’的链接标签 参数类型: Boolean 默认: false 3. stylesheet 说明: 添加一个外部的css样式文件 参数类型: URL-string 默认: null 4. noPrintSelector 说明: 跳过打印的标签, 元素带有class=”no-print”时跳过打印. 参数类型: Any valid jQuery-selector 默认: “.no-print” 5. iframe 说明: 是否从iframe中打印, 可以使用自己定义的iframe元素, 注意: 设置为false时, chrome会拦截. 参数类型: Any valid jQuery-selector or Boolean 默认: true, 如果iframe参数无效, 则创建一个隐藏的iframe 6. append/prepend 说明: 添加选中的html元素或自定义标签, prepend(在前面添加), append(在后面添加) 参数类型: Any valid jQuery-selector or HTML-text 默认: null 7. title 说明: 修改打印标题, 默认html文档标题 参数类型: string 默认: null","categories":[],"tags":[{"name":"jQuery.js","slug":"jQuery-js","permalink":"http://mysaul.com/tags/jQuery-js/"},{"name":"jQuery.print.js","slug":"jQuery-print-js","permalink":"http://mysaul.com/tags/jQuery-print-js/"}],"keywords":[]},{"title":"Ubuntu14.04下安装MongoDB并创建用户","slug":"Ubuntu14-04下安装MongoDB并创建用户","date":"2017-01-06T06:06:38.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2017/01/06/Ubuntu14-04下安装MongoDB并创建用户/","link":"","permalink":"http://mysaul.com/2017/01/06/Ubuntu14-04下安装MongoDB并创建用户/","excerpt":"在 Ubuntu14 下安装 MongoDB 并创建用户开启鉴权 由于阿里云通知我，我的MongoDB服务器有安全漏洞，是因为之前没有设置权限，所以特写次文章","text":"在 Ubuntu14 下安装 MongoDB 并创建用户开启鉴权 由于阿里云通知我，我的MongoDB服务器有安全漏洞，是因为之前没有设置权限，所以特写次文章 安装Mongodb1. 下载最新版 MongoDB1$ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1404-3.4.1.tgz 2. 解压下载好的 taz 包, 并重命名12$ tar -zxvf mongodb-linux-x86_64-ubuntu1404-3.4.1.tgz$ mv mongodb-linux-x86_64-ubuntu1404-3.4.1.tgz mongodb 3. 编写配置文件 mongodb.conf123456789101112# 数据库存放路径（这里写的是相对路径）dbpath=data/db# 端口号port=27017# 先把auth关闭，添加用户后再开启auth=false# 日志文件存放路径logpath=mongodb.log# 日志是否追加logappend=true# 后台进程启动fork=true 4. 创建数据库存放目录，并修改权限12$ mkdir -p data/db$ chmod -R 777 data/db/ 5. 启动服务1$ ./bin/mongod -f mongodb.conf 6. 连接到 mongodb12345./bin/mongoMongoDB shell version v3.4.1connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.1&gt; 请自行设置 $PATH这时候我们看一下log日志后有3个警告信息分别为，暂时我还不会解决…1). WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine2). WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’. We suggest setting it to ‘never’3). WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’ 创建用户并使用 注意：MongoDB 2.6 版本之前使用 db.addUser() 创建用户, 2.6 版本之后使用 db.createUser() 创建用户 123456789101112131415161718192021222324addUser() 参数只有两个 1. 用户名 2. 密码createUser() 有多个参数, 分别为 &#123; user: &lt;name&gt;, pwd: &lt;password&gt;, customData: &lt;用户说明&gt;, roles: [ &#123; role: &lt;角色类型&gt;, db: &lt;创建在哪个数据库&gt; &#125; ] &#125;数据库角色类型分别有: ( read: 只读 readWrite: 读写 dbAdmin: 数据库管理权限 dbOwner: 前三者的集合体，有前三者所有的权限 userAdmin: 用户管理 )了解了这么多，接下来就要创建用户了 1. 创建用户 创建一个admin账户用来管理所有的用户，再创建一个个人账号用来管理所有的数据库 12345# 创建一个admin，给予userAdminAnyDatabase的权限，可以管理所有的用户：&gt; db.createUser(&#123;user: &apos;useradmin&apos;, pwd: &apos;useradmin&apos;, roles: [&#123;role: &apos;userAdminAnyDatabase&apos;, db: &apos;admin&apos;&#125;]&#125;)# 创建一个个人用户，给予dbAdminAnyDatabase的权限，可以管理所有数据库：&gt; db.createUser(&#123;user: &apos;zail&apos;, pwd: &apos;zail&apos;, roles: [&#123;role: &apos;dbAdminAnyDatabase&apos;, db: &apos;admin&apos;&#125;]&#125;)# 之后就可以通过 admin 账户来管理用户， 通过自己的账号来管理所有的数据库 2. 开启鉴权认证123456789101112# 关闭 MongoDB&gt; use admin&gt; db.shutdownServer()# 修改配置文件 mongodb.conf 中的 auth=true# 保存# 重启 MongoDB$ ./bin/mongod -f mongodb.conf# 之后就可以使用账号链接 MongoDB 了$ ./bin/mongo admin -u admin -p admin$ ./bin/mongo admin -u zail -p zail","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://mysaul.com/tags/MongoDB/"}],"keywords":[]},{"title":"如何写pm2 start文件","slug":"如何写pm2-start文件","date":"2016-12-02T03:22:54.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/12/02/如何写pm2-start文件/","link":"","permalink":"http://mysaul.com/2016/12/02/如何写pm2-start文件/","excerpt":"🍺 pm2 是啥我就不过多介绍了, 总之是神器. pm2 写一个配置文件就可以运行你的代码. 写出配置文件后就不用每次写命令时带很多参数了, 减轻了命令行的代码量.同时查看log信息也不需要用命令行查看, 直接把log文件打印到项目中随时查看log, 方便快捷.","text":"🍺 pm2 是啥我就不过多介绍了, 总之是神器. pm2 写一个配置文件就可以运行你的代码. 写出配置文件后就不用每次写命令时带很多参数了, 减轻了命令行的代码量.同时查看log信息也不需要用命令行查看, 直接把log文件打印到项目中随时查看log, 方便快捷. 项目根目录新建一个 pm2.config.json 文件 👇 123456789101112131415161718&#123; // 项目名称 \"name\": \"app name\", // 启动文件 \"script\": \"./app.js\", // 是否监听文件变化 \"watch\": true, // 如果你是koa框架需要加入 --harmony 或者别的参数都可以加到这里 \"node_args\": \"--harmony\", // log 相关 // 输出 log 时, 前缀时间格式化 \"log_date_format\": \"YYYY-MM-DD HH:mm Z -&gt; \", // out log 文件地址 \"out_file\": \"./logs/pm2-out.log\", // error log 文件地址 \"error_file\": \"./logs/pm2-error.log\"&#125; 更多参数请查看 官方文档","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://mysaul.com/tags/Node-js/"},{"name":"pm2","slug":"pm2","permalink":"http://mysaul.com/tags/pm2/"}],"keywords":[]},{"title":"初体验facebook开源包管理工具yarn","slug":"初体验facebook开源包管理工具yarn","date":"2016-10-18T06:27:07.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/10/18/初体验facebook开源包管理工具yarn/","link":"","permalink":"http://mysaul.com/2016/10/18/初体验facebook开源包管理工具yarn/","excerpt":"害怕 facebook 网站小伙伴们被墙, 搞了传到 csdn 的图片一张. 我勒个去，现在的 node 相关的开源社区太活跃了，github 上 facebook 活跃度已经是第二了，第一是微软🙄. yarn 又是什么？ →_→ 包管理工具 包管理工具不是有: npm、bower …… 了吗!？ →_→ 好用吗？下载速度快吗？安全吗？可靠吗？有良好的依赖吗？ 不知道 … 凑合用吧.","text":"害怕 facebook 网站小伙伴们被墙, 搞了传到 csdn 的图片一张. 我勒个去，现在的 node 相关的开源社区太活跃了，github 上 facebook 活跃度已经是第二了，第一是微软🙄. yarn 又是什么？ →_→ 包管理工具 包管理工具不是有: npm、bower …… 了吗!？ →_→ 好用吗？下载速度快吗？安全吗？可靠吗？有良好的依赖吗？ 不知道 … 凑合用吧. 哈哈哈哈开始说之前, 我也说不出来 npm 是不是好用, 但是慢不是一个人说的, 我觉得也慢. yarn 还简化了 npm 的使用. 就冲这两点, 也应该看一下. 好下面直接开始! 安装1$ npm install -g yarn 初始化1234$ yarn init# 查看是否正确安装好$ yarn --version 我尼玛和 npm 有什么区别!？ 别着急嘛 管理依赖添加依赖12# 这里不需要 --save 参数直接可以写到 package.json 文件里, 后面可跟@version版本号、也可以跟@tag 指代git上的推送的tag$ yarn add [package] 更新依赖12# 更新某个包, 同时也有 @version 、 @tag. 不加包名即更新所有依赖$ yarn upgrade [package] 移除依赖12# 移除某个包 $ yarn remove [package] 如果有 package.json 或者是 bower.json12# 直接 yarn 或者 yarn install 即可安装所有依赖$ yarn 下一个包玩玩1234567891011$ yarn add g2yarn add v0.15.1info No lockfile found.[1/4] 🔍 Resolving packages...[2/4] 🚚 Fetching packages...[3/4] 🔗 Linking dependencies...[4/4] 📃 Building fresh packages...success Saved lockfile.success Saved 1 new dependency└─ g2@2.0.4✨ Done in 2.10s. 运行下来没有那么多警告, 还有很友好的时间等其他的提示, 还会直接建立 package.json 文件. 12345&#123; &quot;dependencies&quot;: &#123; &quot;g2&quot;: &quot;^2.0.4&quot; &#125;&#125; 是不是用着很舒服呢？ 至于那个什么锁的东西我还不会…😁哈哈哈哈","categories":[],"tags":[],"keywords":[]},{"title":"理解MongoDB的mapReduce使用及流程","slug":"理解MongoDB的mapReduce使用及流程","date":"2016-10-18T02:39:11.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/10/18/理解MongoDB的mapReduce使用及流程/","link":"","permalink":"http://mysaul.com/2016/10/18/理解MongoDB的mapReduce使用及流程/","excerpt":"mapReduce 是一个多层分组查询的方法(这是个人理解的) 可以分为四层 第一层: query 层 // 意思是把数据进行筛选 第二层: map 方法层 // 分组数据处理, 把数据作为 key values 的形式传进 reduce 层 第三层: reduce 方法层 // 统计函数, 把传进来的 key values 转换成想要的 key value 形式 第四层: finalize 方法层 // 最后的确认函数 Map-Reduce 例子","text":"mapReduce 是一个多层分组查询的方法(这是个人理解的) 可以分为四层 第一层: query 层 // 意思是把数据进行筛选 第二层: map 方法层 // 分组数据处理, 把数据作为 key values 的形式传进 reduce 层 第三层: reduce 方法层 // 统计函数, 把传进来的 key values 转换成想要的 key value 形式 第四层: finalize 方法层 // 最后的确认函数 Map-Reduce 例子 12345678910111213141516171819202122db.collection.mapReduce( // 第二步: 执行 map 函数, 必须有 emit 方法 function () &#123; // emit 方法遍历 collection 中所有的记录 emit(this.user_name, 1); // -&gt; &#123;key: mark, values: [1,1,1,1]&#125; &#123;key: runoob, values: 1&#125; &#125;, // 第三步: 执行 reduce 函数, 遍历 map 函数得出的对象数组 function (key, values) &#123; // -&gt; [&#123;key: mark, valuse: [1,1,1,1]&#125;, &#123;key: runoob, values: 1&#125;] // return 的数据 为需要存储的数据 -&gt; &#123;value: &#123;value1: 4, value2: 4&#125;&#125; return &#123;value1: values.length, value2: Array.sum(values)&#125;; &#125;, // 第一步: collection 和 条件 相关 &#123; out: 'post_total', // &#123; merge: \"collection\" &#125; 如果有 collection 会重写 数据, 可 merge query: &#123;status: 'active'&#125;, // 最后确定的方法 finalize: function (key, value) &#123; &#125; &#125;)","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://mysaul.com/tags/MongoDB/"}],"keywords":[]},{"title":"分享知乎的一个话题。","slug":"分享知乎的一个话题。","date":"2016-08-19T04:21:30.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/08/19/分享知乎的一个话题。/","link":"","permalink":"http://mysaul.com/2016/08/19/分享知乎的一个话题。/","excerpt":"有哪些短小却令人惊叹的 JavaScript 代码？","text":"有哪些短小却令人惊叹的 JavaScript 代码？","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mysaul.com/tags/javascript/"}],"keywords":[]},{"title":"原生javascript如何解决ajax跨域的问题？","slug":"原生javascript如何解决ajax跨域的问题？","date":"2016-08-05T02:53:03.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/08/05/原生javascript如何解决ajax跨域的问题？/","link":"","permalink":"http://mysaul.com/2016/08/05/原生javascript如何解决ajax跨域的问题？/","excerpt":"大家知道 jQuery 解决 ajax 跨域的问题很方便，直接用 jsonp 的方式提交就 ok ，网上有很多解决的办法，但是有些时候我们不得不用原生 js 来写很多东西，所以我今天把原生 js 解决 ajax 跨域的问题用一个很简单的方法来实现。","text":"大家知道 jQuery 解决 ajax 跨域的问题很方便，直接用 jsonp 的方式提交就 ok ，网上有很多解决的办法，但是有些时候我们不得不用原生 js 来写很多东西，所以我今天把原生 js 解决 ajax 跨域的问题用一个很简单的方法来实现。 首先来理解它的原理: 实际上实现跨域不是用的传统的 XMLHttpRequest 对象，而是用了 script 标签可以访问其它的网址的 js 来实现的。 直接上代码 12345678910111213141516171819202122232425262728293031function jsonp(options) &#123; options = options || &#123;&#125;; if (!options.url || !options.callback) &#123; throw new Error(\"参数不合法\"); &#125; // 创建 script 标签并加入到页面中 var callbackName = ('jsonpcallback_' + Math.random()).replace(\".\", \"\"); // 随机一个比较长的回调函数名称 var oHead = document.getElementsByTagName('head')[0]; options.data[options.callback] = callbackName; // 把回调函数名字加入到 options.data 中 var params = formatParams(options.data); // 格式化数据 var oS = document.createElement('script'); oHead.appendChild(oS); // 创建jsonp回调函数 window[callbackName] = function (json) &#123; oHead.removeChild(oS); clearTimeout(oS.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); &#125;; // 发送请求 oS.src = options.url + '?' + params; // 超时处理 if (options.time) &#123; oS.timer = setTimeout(function () &#123; window[callbackName] = null; oHead.removeChild(oS); options.error &amp;&amp; options.error(&#123; message: \"超时\" &#125;); &#125;, options.time); &#125;&#125; formatParams 方法 12345678function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + \"=\" + encodeURIComponent(data[name])); &#125; arr.push((\"v=\" + Math.random()).replace(\".\", \"\")); return arr.join(\"&amp;\");&#125; 执行 1234567891011121314jsonp(&#123; url: \"http://www.XXX.com/\", callback: \"callback\", // callback 的名称要记住 time: 5000, data: &#123; a: 1 &#125;, success: function (data) &#123; console.log(\"提交成功!\"); &#125;, error: function (err) &#123; console.log(err); &#125;&#125;); 可以在浏览器中看到，我们向服务器端发送的数据是 GET 请求，数据有两个，一个是参数 a: 1 另一个是 callback: jsonpcallback_***. 为什么会有两个参数？ 其实我们没有发送数据请求， 我们只是创建了一个 script 标签， 连接到一个 js 文件，来执行这个 js 文件罢了。 所以就要后台返回的值需要是一段执行的 js 方法， 方法名称已经用 callback 参数发送过去了，只需要把参数执行就可以了. 后台返回的示例（以 callback: jsonpcallback_*** 为例）， json 为后台返回的数据，执行这个方法就可以执行 success 中写的方法了 1jsonpcallback_***(json)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mysaul.com/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://mysaul.com/tags/ajax/"}],"keywords":[]},{"title":"iPhone 网页中手机号码显示样式问题。","slug":"iPhone-网页中手机号码显示样式问题。","date":"2016-06-26T14:05:26.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/06/26/iPhone-网页中手机号码显示样式问题。/","link":"","permalink":"http://mysaul.com/2016/06/26/iPhone-网页中手机号码显示样式问题。/","excerpt":"我们在做 iPhone 上的网页的时候会遇到手机号码莫名显示为蓝色的问题,这是 iPhone 上的 safari 内核的浏览器会自动为手机号码添加 link 以及 link 的样式，如果这是我们不需要的，该如何禁用掉呢？","text":"我们在做 iPhone 上的网页的时候会遇到手机号码莫名显示为蓝色的问题,这是 iPhone 上的 safari 内核的浏览器会自动为手机号码添加 link 以及 link 的样式，如果这是我们不需要的，该如何禁用掉呢？ 我们可以添加 meta 标签来禁用掉手机号码自动添加link的功能 1&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://mysaul.com/tags/web/"},{"name":"iPhone","slug":"iPhone","permalink":"http://mysaul.com/tags/iPhone/"}],"keywords":[]},{"title":"如何解决Zepto.js 和 jQuery.js 事件多次执行多次bind?","slug":"如何解决Zepto-js-和-jQuery-js-事件多次执行多次bind","date":"2016-06-26T09:51:48.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/06/26/如何解决Zepto-js-和-jQuery-js-事件多次执行多次bind/","link":"","permalink":"http://mysaul.com/2016/06/26/如何解决Zepto-js-和-jQuery-js-事件多次执行多次bind/","excerpt":"Zepto.js 和 jQuery.js 绑定click事件的时候,如果多次执行监听事件,会出现累积bind同一个事件的问题。 这时候执行该事件会根据绑定的次数来多次执行该事件，如何解决这个问题？","text":"Zepto.js 和 jQuery.js 绑定click事件的时候,如果多次执行监听事件,会出现累积bind同一个事件的问题。 这时候执行该事件会根据绑定的次数来多次执行该事件，如何解决这个问题？ Zepto.js 和 jQuery.js 绑定click事件的时候,如果多次执行监听事件,会出现累积bind同一个事件的问题。 这时候执行该事件会根据绑定的次数来多次执行该事件，如何解决这个问题？ 如何让事件多次执行监听而只bind一次。 1$(‘.class’).unbind(‘click’).on(‘click’, function()&#123; … &#125;); 可以通过 先解绑 click 事件，然后再 bind click 事件来解决。","categories":[],"tags":[{"name":"jQuery.js","slug":"jQuery-js","permalink":"http://mysaul.com/tags/jQuery-js/"},{"name":"Zepto.js","slug":"Zepto-js","permalink":"http://mysaul.com/tags/Zepto-js/"}],"keywords":[]},{"title":"如何编写Markdown文件","slug":"如何编写Markdown文件","date":"2016-06-26T09:35:01.000Z","updated":"2017-03-27T10:48:07.000Z","comments":true,"path":"2016/06/26/如何编写Markdown文件/","link":"","permalink":"http://mysaul.com/2016/06/26/如何编写Markdown文件/","excerpt":"使用 Markdown 的优点 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。","text":"使用 Markdown 的优点 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 详细信息查看 转载的GitBook 标题语法123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 无序列表123- 1- 2- 3 1 2 3 有序列表123* 1* 2* 3 1 2 3 引用1&gt; 这里是引用的内容 这里是引用的内容 链接1段落中需要插入链接： [baidu](www.baidu.com) 点击可以访问. 段落中需要插入链接： baidu 点击可以访问. 插入图片1![pic](https://www.getcloudapp.com/assets/images/app_image_win@2x.jpg) 粗体1**粗体** 这里是粗体 斜体1*斜体* 这里是斜体 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码1`code` code 分割线1***","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://mysaul.com/tags/Markdown/"}],"keywords":[]}]}